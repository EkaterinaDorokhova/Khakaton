# Пути реализации продукта

## Возможности модели 

Использованная в данном проекте модель машинного обучения ArchiStyles была изначально обучена на 9 стилях. Для того, чтобы продемонстрировать возможности развития модели, она дополнительно была дообучена командой на ещё двух стилях (Чикагская школа и Эдвардианский стиль). Таким образом, разработанная модель может определять 11 распространенных в Западной и Центральной Европе архитектурных стилей:

1. Art Nouveau (Модерн)
2. Baroque (Барокко)
3. Beaux-Arts (Бозар)
4. Byzantine (Византийская архитектура)
5. Chicago School (Чикагская архитектурная школа)
6. Deconstructivism (Деконструктивизм)
7. Edwardian (Эдвардианская архитектура)
8. Gothic (Готика)
9. Palladian (Палладианство)
10. Postmodern (Постмодернизм)
11. Romanesque (Романская архитектура)

Выбор данных стилей был связан с доступностью этих наборов данных для обучения модели. При наличии ресурсов (в первую очередь, людей в команде и времени), более глубоко погружения в процесс сбора данных и выполнения ряда дополнительных шагов, модель может быть существенно доработана.

---

## Ограничения модели

Актуальная версия модели имеет ряд ограничений, на устранение которые могут быть направлены будущие доработки:

### 1. Ошибки в определении стиля
Модель может ошибаться при определении архитектурного стиля. Повышение точности возможно за счёт доработки алгоритмов и увеличения объёма данных.

### 2. Ограниченный список стилей
Модель не распознаёт стили, которые не входят в обученные 11. Решение — расширение списка стилей и добавление географической локализации.

### 3. Работа со смешанными стилями
Сложности возникают при анализе зданий, относящихся к нескольким стилям (например, эклектика, фьюжн). Решением было бы изменить формат ответов модели таким образом, чтобы она сообщала о своей "неуверенности" в определении стиля. В таком случае более корректным было бы ответить, что здание на фото относится к тем или иным стилям с некоторой вероятностью. Например:
> "Здание имеет признаки нескольких стилей: 60% — модерн, 40% — постмодернизм."

---

## Решение ограничений - собственное решение

Решением перечисленных ограничений может быть переход к реализации продукта с развёртыванием модели YOLOv5 на ресурсах и в собственном окружении создателей продукта, т.к. YOLOv5 сама по себе является моделью машинного обучения, а не библиотекой или инструментом, и может быть использована непосредственно без применения инструментов-посредников. На данный момент модель реализована с использованием Roboflow: платформы для разметки данных, создания датасетов и обучения моделей машинного обучения, что имеет как свои преимущества, так и недостатки. Использование Roboflow не является обязательным инструментом для реализации проекта.

### Преимущества использования Roboflow:
1. Удобный интерфейс для разметки изображений и создания датасетов.
2. Автоматическая аугментация данных.
3. Экспорт данных в различных форматах (YOLO, COCO, Pascal VOC), что делает его совместимым с большим количеством моделей машинного обучения.
4. Хостинг датасетов и моделей в облаке, предоставление к ним удобного доступа через API.
5. Прямая интеграция с YOLOv5, что значительно упрощает процесс обучения и развертывания модели.

### Недостатки использования Roboflow:
- Ограничение функционала платформы.
- Зависимость от сторонних сервисов.

В целом, использование Roboflow значительно упрощает разработку проекта, особенно при отсуствии большого опыта в области машинного обучения. При наличии необходимых знаний и опыта, проект можно реализовать и без использования Roboflow, и это существенно расширит возможности изменения настроек модели под нужды, цели и задачи авторов проекта.

---

## Реализация проекта без Roboflow

При самостоятельном развертывании модели, открывает ряд возможностей, недоступных при использовании готовых платформ.

### Преимущества самостоятельного развёртывания модели:
1. **Полный контроль над обучением:** выбор архитектуры модели, настройка гиперпараметров и методов аугментации.
2. **Использование любых данных:** возможность работы с нестандартными датасетами и комбинирования разных датасетов.
3. **Глубокое понимание ML-процессов:** самостоятельная реализация проекта дает возможность глубже понять принципы работы моделей машинного обучения, тонкости настройки гиперпараметров и выбора оптимальной архитектуры..
4. **Свобода в развертывании:** возможность интеграции модели в различные среды.
5. **Оптимизация производительности:** повышение скорости инференса и уменьшение зависимости от ресурсов.

---

## Масштабирование проекта

Самостоятельное развертывание модели откроеn возможности для масштабирования проекта и позволит расширить функциональность. В целом, самостоятельное развертывание модели даёт полный контроль над проектом и позволяет масштабировать его в соответствии с целями и ресурсами, но требует больше усилий, технических знаний и времени.

### 1. Масштабирование датасета:
- Увеличение объёма данных для повышения точности модели.
- Добавление новых стилей, включая редкие и регионально-специфичные.
- Создание специализированных моделей для отдельных городов.

### 2. Масштабирование функциональности:
- Эксперименты с архитектурой моделей позволят выбирать и настраивать архитектуру модели (например, YOLOv5), оптимизировать её под задачи.
- Реализация multi-label классификации - определение нескольких стилей на изображении.
- Интеграция с любыми приложениями (веб-сервисы, мобильные приложения, Telegram-боты).
- Оптимизация производительности (настройка параметров для увеличения скорости работы).

---

## Гиперпараметры модели

Для повышения производительности модели может быть произведена точная настройка следующих параметров:
1. Скорость обучения (learning rate): определяет, как быстро модель обновляет веса.
2. Размер батча (batch size): количество изображений на одну итерацию.
3. Количество эпох (epochs): количество проходов по всему набору данных.
4. Оптимизатор (optimizer): алгоритм для обновления весов.
5. Архитектура модели: выбор структуры модели для оптимизации, ускорения обучения и повышения точности, например, использование предобученных весов.

---

# План реализации проекта при самостоятельном развертывании сервисов

## 1. Определение требований и целей

- **Четкое определение целей проекта**:
  - Архитектурные стили, которые нужно определять.
  - Требуемая точность модели.
  - Необходимая скорость инференса.

- **Анализ целевой аудитории**:
  - Как пользователи будут взаимодействовать с моделью: через веб-интерфейс, мобильное приложение или API.
  - Интеграция с другими сервисами.

- **Оценка доступных ресурсов**:
  - Финансовый бюджет.
  - Наличие команды специалистов.
  - Доступные вычислительные мощности.

---

## 2. Сбор и подготовка данных

### Сбор данных

- Собрать разнообразный набор изображений, представляющих различные архитектурные стили.
- Использовать различные источники:
  - Фотостоки.
  - Архитектурные сайты.
  - Социальные сети.

### Разметка данных

- Выбор инструментов для ручной разметки: LabelImg, CVAT, makesense.ai.
- Разметка изображений:
  - Указать bounding box для каждого здания.
  - Присвоить изображению соответствующий архитектурный стиль.
- Качество разметки:
  - Обеспечить точность, полноту и согласованность разметки.
- Рассмотреть возможность использования сервисов автоматической разметки для ускорения процесса.

#### Пример кода для генерации разметки в формате YOLO
```python
import os

# Пути к данным
data_dir = "/content/drive/MyDrive/Хакатон/data/data_for_model"  # Общая папка с данными
splits = ['train', 'valid', 'test']  # Три раздела данных

# Список классов и их ID
classes = sorted([d for d in os.listdir(os.path.join(data_dir, 'train')) if os.path.isdir(os.path.join(data_dir, 'train', d))])
class_to_id = {cls_name: i for i, cls_name in enumerate(classes)}
print(f"Классы и их ID: {class_to_id}")

# Генерация разметки для всех сплитов
for split in splits:
    split_path = os.path.join(data_dir, split)
    print(f"Создаём разметку для: {split}")
    for class_name in classes:
        class_path = os.path.join(split_path, class_name)
        for img_name in os.listdir(class_path):
            if img_name.lower().endswith(('.jpg', '.jpeg', '.png')):
                # Создаём файл аннотации рядом с изображением
                label_file = os.path.join(class_path, f"{os.path.splitext(img_name)[0]}.txt")
                with open(label_file, 'w') as f:
                    f.write(f"{class_to_id[class_name]} 0.5 0.5 1.0 1.0\n")  # YOLO формат для классификации
    print(f"Разметка для {split} создана успешно!")
```

В результате мы получим текстовые файлы .txt рядом с каждым изображением, где каждый файл содержит строку:
```bash
<class_id> 0.5 0.5 1.0 1.0
```

### Подготовка датасета
- Разделить данные на обучающую, валидационную и тестовую выборки.
- Сохранить данные в формате, совместимом с выбранным фреймворком машинного обучения.

```python
# Установка библиотеки
pip install split-folders

# Можно использовать библиотеку shutil и splitfolders для автоматического разделения данных
import splitfolders

# Исходные данные
input_folder = "/content/drive/MyDrive/Хакатон/data/data_for_model/original_data"  # Исходная папка с изображениями по классам

# Сохранение разделённых данных
output_folder = "/content/drive/MyDrive/Хакатон/data/data_for_model"

# Разделение на train, valid, test (80%, 10%, 10%)
splitfolders.ratio(input_folder, output=output_folder, seed=42, ratio=(0.8, 0.1, 0.1), move=True)

print("Данные успешно разделены на train, valid и test!")
```

В результате данные будут разделены в папку с такой структурой:
```bash
output_folder/
    train/
        class1/
        class2/
    val/
        class1/
        class2/
    test/
        class1/
        class2/
```

Данные сохраняются в формате, совместимом с YOLOv5. Для YOLOv5 создаётся файл data.yaml, который укажет пути к данным, количество классов и их названия.
```python
import os

# Пути к разделённым данным
train_path = "/content/drive/MyDrive/Хакатон/data/data_for_model/train"
val_path = "/content/drive/MyDrive/Хакатон/data/data_for_model/valid"

# Список классов
classes = sorted(os.listdir(train_path))

# Создаём YAML-содержимое
data_yaml = f"""
train: {train_path}
val: {val_path}
nc: {len(classes)}
names: {classes}
"""

# Сохраняем файл data.yaml
yaml_path = os.path.join("/content/drive/MyDrive/Хакатон/data/data_for_model", "data.yaml")
with open(yaml_path, "w") as f:
    f.write(data_yaml)

print(f"Файл data.yaml успешно создан! Путь: {yaml_path}")
print(data_yaml)

В результате будет создан файл data.yaml с содержимым:
```bash
train: /content/drive/MyDrive/Хакатон/data/data_for_model/train
val: /content/drive/MyDrive/Хакатон/data/data_for_model/valid
nc: 2
names: ['Gothic', 'Baroque']
```

---

## 3. Выбор и обучение модели

### Выбор архитектуры модели

- Исходя из требований к точности, скорости инференса и доступным ресурсам, выбрать архитектуру модели:
  - **Примеры архитектур**: YOLOv5, ResNet, EfficientNet, ViT.
- Мы выбрали **YOLOv5 Classification**, так как:
  - Она лёгкая и быстрая.
  - Обеспечивает хорошую точность для классификации изображений.
  - Имеет подробную документацию и примеры в сети.

### Обучение модели

#### Настройка гиперпараметров
- Количество эпох: 10.
- Размер батча: 64.
- Размер изображений: 128x128 пикселей.

#### Использование PyTorch и YOLOv5
- Клонирование YOLOv5 и установка зависимостей:

```bash
!git clone https://github.com/ultralytics/yolov5
%cd yolov5
!pip install -qr requirements.txt


---


---


---


---


---
